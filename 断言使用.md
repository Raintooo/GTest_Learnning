- [断言使用](#断言使用)
  - [如何使用](#如何使用)
  - [相关API](#相关api)
    - [显式返回](#显式返回)
    - [匹配器模式](#匹配器模式)
    - [布尔表达式](#布尔表达式)
    - [二进制比较](#二进制比较)
    - [字符串比较](#字符串比较)
    - [浮点比较](#浮点比较)
    - [Predicate Assertions](#predicate-assertions)
    - [Format Predicate Assertions](#format-predicate-assertions)
    - [Type Assertions(类型判断)](#type-assertions类型判断)
  - [注意事项](#注意事项)


# 断言使用

上一节讲了如何使用GTest, 里面有提及Assertion使用, 那这一节就细讲Assertion

## 如何使用

从上一节编写最简单GTest就可以看到, ```ASSERT_EQ()```就是一个宏, 其作用
* 就是当条件不成立就打断当前函数并返回,  
  
由此我们可以知道, 
* 其他不同判断的的```ASSERT_*()```都是这个逻辑。

除此之外，断言宏支持流式打印类似C++ ```std::cout```
使用方法：

```C++
#include <gtest/gtest.h>

EXPECT_TRUE(my_condition) << "My condition is not true";
```

## 相关API

### 显式返回

```C++
SUCCEED()/FAIL()
```
显式直接生成成功/失败, 主要用于条件控制, 当测试案例需要返回成功/失败时直接调用，而不是再增加一个条件判断语句


### 匹配器模式

```C++
EXPECT_THAT(value, matcher);
ASSERT_THAT(value, matcher);
```
* value为匹配值，matcher是匹配器
* 作用是 value是否符合matcher，符合返回true，否则false 
* 同时，如果返回匹配失败，会有详细的失败打印，有助于定位

> 详细的匹配器相关内容后续再讲

### 布尔表达式

```C++
EXPECT_TRUE(condition)
ASSERT_TRUE(condition)

EXPECT_FALSE(condition)
ASSERT_FALSE(condition)
```
* 验证条件是true/false

### 二进制比较

```C++
// val1 == val2
EXPECT_EQ(val1,val2)
ASSERT_EQ(val1,val2)

// val1 != val2
EXPECT_NE(val1,val2)
ASSERT_NE(val1,val2)

// val1 < val2
EXPECT_LT(val1,val2)
ASSERT_LT(val1,val2)

// val1 <= val2
EXPECT_LE(val1,val2)
ASSERT_LE(val1,val2)

// val1 > val2
EXPECT_GT(val1,val2)
ASSERT_GT(val1,val2)

// val1 >= val2
EXPECT_GE(val1,val2)
ASSERT_GE(val1,val2)
```

### 字符串比较

```C++
// str1 == str2
EXPECT_STREQ(str1,str2)
ASSERT_STREQ(str1,str2)

// str1 != str2
EXPECT_STRNE(str1,str2)
ASSERT_STRNE(str1,str2)

// str1 == str2, 忽略大小写
EXPECT_STRCASEEQ(str1,str2)
ASSERT_STRCASEEQ(str1,str2)

// str1 != str2, 忽略大小写
EXPECT_STRCASENE(str1,str2)
ASSERT_STRCASENE(str1,str2)
```

### 浮点比较

```C++
EXPECT_FLOAT_EQ(val1,val2)
ASSERT_FLOAT_EQ(val1,val2)

EXPECT_DOUBLE_EQ(val1,val2)
ASSERT_DOUBLE_EQ(val1,val2)

// 计算val1和val2差值是否超过abs_error
// 超过 abs_error返回false否则true
EXPECT_NEAR(val1,val2,abs_error)
ASSERT_NEAR(val1,val2,abs_error)
```

### Predicate Assertions

功能上类似```EXPECT_TRUE ```，但是```EXPECT_TRUE ```只能输入表达式，而```EXPECT_PRED* ```则是自定义函数，更加灵活

```C++
// pred是函数指针，valx是传参
EXPECT_PRED1(pred,val1)
EXPECT_PRED2(pred,val1,val2)
EXPECT_PRED3(pred,val1,val2,val3)
EXPECT_PRED4(pred,val1,val2,val3,val4)
EXPECT_PRED5(pred,val1,val2,val3,val4,val5)

ASSERT_PRED1(pred,val1)
ASSERT_PRED2(pred,val1,val2)
ASSERT_PRED3(pred,val1,val2,val3)
ASSERT_PRED4(pred,val1,val2,val3,val4)
ASSERT_PRED5(pred,val1,val2,val3,val4,val5)
```

例子：
```C++
bool IsZero(int a)
{
    return a == 0;
}

TEST(PredSuit, pred1)
{
    EXPECT_PRED1(IsZero, 0);
}
```

需要注意的是，如果函数是重载函数或者模板函数，就需要显式声明函数类型否则会编译报错

```C++
EXPECT_PRED1(static_cast<bool (*)(int)>(IsPositive), 5);
EXPECT_PRED1(static_cast<bool (*)(double)>(IsPositive), 3.14);

template <typename T>
bool IsNegative(T x) {
  return x < 0;
}
...
EXPECT_PRED1(IsNegative<int>, -5);  // Must specify type for IsNegative
```

### Format Predicate Assertions

相比较 Predicate Assertions，Format Predicate Assertions可以自定义格式化打印调试信息，有利于定位排查

```C++
EXPECT_PRED_FORMAT1(pred_formatter,val1)
EXPECT_PRED_FORMAT2(pred_formatter,val1,val2)
EXPECT_PRED_FORMAT3(pred_formatter,val1,val2,val3)
EXPECT_PRED_FORMAT4(pred_formatter,val1,val2,val3,val4)
EXPECT_PRED_FORMAT5(pred_formatter,val1,val2,val3,val4,val5)

ASSERT_PRED_FORMAT1(pred_formatter,val1)
ASSERT_PRED_FORMAT2(pred_formatter,val1,val2)
ASSERT_PRED_FORMAT3(pred_formatter,val1,val2,val3)
ASSERT_PRED_FORMAT4(pred_formatter,val1,val2,val3,val4)
ASSERT_PRED_FORMAT5(pred_formatter,val1,val2,val3,val4,val5)
```

pred_formatter 函数指针格式是：

```C++
testing::AssertionResult PredicateFormatter(const char* expr1,
                                            const char* expr2,
                                            ...
                                            const char* exprn,
                                            T1 val1,
                                            T2 val2,
                                            ...
                                            Tn valn);
```

> testing::AssertionResult类在GTest里表示测试结果，在许多自定义测试函数返回结果时都是需要返回这个类型
> 同时AssertionResult可以直接用```<<```追加打印

例子：
```C++
testing::AssertionResult IsPositive(const char* exp, int a)
{
    if(a >= 0)
        return testing::AssertionSuccess();
    else 
        return testing::AssertionFailure()<< "unfortunately "<< exp<< " is negative";
}

TEST(PredSuit, pred2)
{
    int d = -1;
    EXPECT_PRED_FORMAT1(IsPositive, d);
}
```

### Type Assertions(类型判断)

当我们测试的函数是模板函数时，我们就很有必要测试传入的参数类型是否符合我们要求，GTest就提供了相关API

```C++
::testing::StaticAssertTypeEq<T1, T2>();
```

这个判断会运行在编译期，如果T1和T2类型不一样，那么就直接是编译器报错
> 本质上这个API实现就是利用了 ```std::is_same<>```

## 注意事项

上面提到的API，我们都可以在普通的函数中调用，但是要注意：
* 调用函数一定是```void```类型的函数
* 如果是非```void```类型，那么会在编译期间报错