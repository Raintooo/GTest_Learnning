- [类型测试](#类型测试)
  - [使用方法](#使用方法)
  - [扩展](#扩展)
    - [解决办法](#解决办法)

# 类型测试

假设你想测试一组模板函数，你希望测试不同类型传入是否合法并且是否得到预期值，那么就需要对类型进行测试

想象一下：  
你可以为你想测试的每种类型分别编写一个 TEST 或 TEST_F（甚至可以将测试逻辑提取到一个函数模板中，然后在 TEST 中调用它），但这种方法很繁琐且难以扩展：如果你想对 n 种类型运行 m 个测试，最终将不得不编写 m*n 个测试项。

类型化测试允许你在一组类型列表上重复相同的测试逻辑。你只需编写一次测试逻辑，但在编写类型化测试时必须知道类型列表。

## 使用方法

具体操作方法如下：

* 定义测试模板类，需要继承自```::testing::Test```
```C++
template <typename T>
class SimTest : public ::testing::Test
{
    // ...
};
```

* 需要关联需要的测试类型到模板类
```C++
using SimType = ::testing::Types<int, char, short>;
TYPED_TEST_SUITE(SimTest, SimType);
```

* 使用```TYPED_TEST```定义测试函数

```C++
TYPED_TEST(SimTest, MySimTest)
{
    GTEST_LOG_(INFO)
        << "is int type: "<< std::is_same<int, TypeParam>::value;
}
```
## 扩展

上面的例子我买知道了简单的类型测试例子，但是现在有一个需求：

**假如我们开发的是接口，当我们提供测试案例时，我们也不知道外部将会传入什么类型，那么怎么办呢**

### 解决办法

回顾 [值参数化](值参数化测试.md)，类型参数序列化可以解决类似问题，我们可以定义好测试逻辑，类型传入交给外部。

那么怎么做呢？

* 看上面例子，只需要把：
```C++
using SimType = ::testing::Types<int, char, short>;
TYPED_TEST_SUITE(SimTest, SimType);
```
这部分放到头文件，供外部修改